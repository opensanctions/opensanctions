{
  "traces": [],
  "train": [],
  "demos": [],
  "signature": {
    "instructions": "Task: Extract, categorize, and clean organization/person names from free-form input text. Return names grouped into full_name, alias, weak_alias, and previous_name, removing non-name noise. Preserve each extracted name exactly as it appears in the input (except trimming outer whitespace and stripping clearly extraneous surrounding punctuation). Output must be a single JSON object with only the four specified keys, each an array of strings.\n\nInput: A single free-form string. It may contain HTML entities, punctuation, parenthetical descriptors or alternates, multiple names separated by delimiters, and noise like addresses or metadata.\n\nPreprocessing (allowed minimal normalization):\n- Decode common HTML entities (e.g., &#39; → ', &amp; → &, &quot; → \") before any processing. Do not otherwise normalize characters.\n- Treat both ASCII parentheses and full-width CJK parentheses as parentheses:\n  • ASCII: ( )\n  • Full-width: （ ）\n- Treat both ASCII slash and full-width slash as alternate separators inside parentheses: / and ／.\n\nCore rules (preserve exact text; no normalization beyond the above):\n1) Do not normalize names\n   - Do NOT change casing; keep the exact case from input.\n   - Do NOT add, remove, or modify internal spaces.\n   - Do NOT expand/contract corporate suffixes (e.g., keep “Ltd”, “Ltd.”, “Limited”, “AG”, “GmbH”, “Inc.” exactly).\n   - Do NOT title/lower/upper-case names.\n   - Do NOT invent names not present in the input.\n\n2) Valid characters and trimming\n   - Keep punctuation commonly occurring in names: periods, hyphens, apostrophes, ampersands, slashes (e.g., “Ltd.”, “O’Connor”, “Smith & Co”, “A/S”, “S.A.”).\n   - Treat relational connectors within person names (e.g., “S/O”, “D/O”, “W/O”) as valid name text.\n   - Strip only clearly extraneous surrounding characters that wrap the entire name (e.g., paired or unpaired surrounding quotes, enclosing parentheses that wrap the whole name, trailing commas/semicolons from formatting).\n   - Trim leading/trailing whitespace only. Do not alter internal spacing.\n\n3) Categorization logic\n   - previous_name: Explicit former-name cues only:\n     “formerly”, “formerly known as”, “fka”, “f/k/a”, “previously”, “name changed from”, “old name”, “ex-”.\n     Example: “SANTANDER CONSUMER BANK (FORMERLY AKB BANK AG)”\n       ⇒ full_name: [\"SANTANDER CONSUMER BANK\"], previous_name: [\"AKB BANK AG\"].\n   - alias (strong alias): Explicit alternate/trading name cues only:\n     “aka”, “a.k.a.”, “also known as”, “dba”, “doing business as”, “t/a”, “trading as”, “operating as”, “brand”.\n   - alias (parenthetical alternates/transliterations):\n     When parentheses are attached directly to a name token (person or org segment) to present alternate spellings/transliterations/variants, treat the items in parentheses as explicit alternates and place the expanded combinations in alias (not weak_alias). See Section 4.\n   - weak_alias: Only for explicitly labeled abbreviations or short forms:\n     “abbr”, “abbrev.”, “short name”, “short form”, “initials”, “ticker”.\n     Do not infer weak_alias merely because a string looks abbreviated.\n   - full_name: All names presented as names without explicit alias/previous/short-form labels. If multiple unlabeled names appear (e.g., separated by semicolons or listed), put each into full_name.\n\n4) Parenthetical alternates expansion (important)\n   - Detect alternates when a token is immediately followed or preceded by parentheses containing variant(s):\n     Patterns like “First(AltFirst) Last(AltLast1/AltLast2)” or “Org(Alt1/Alt2) Ltd.”\n   - For each such token, define its variant list as: [base token outside parentheses, then each parenthetical alternate in order].\n   - Construct full-name strings by the cross-product across tokens’ variant lists.\n   - The primary full_name is the combination using only base tokens (those outside parentheses).\n   - Add all other combinations (any that use at least one parenthetical alternate) to alias.\n   - Include the base token for tokens without parentheses when combining with alternates on other tokens.\n   - Do not output standalone partial tokens (e.g., just a surname variant) unless the input itself presents them standalone.\n   - Ordering for alias expansions: iterate tokens left-to-right; within each token, use variants in the order they appear (base first, then alternates). Exclude the all-base combination (already in full_name).\n   - Parentheses equivalence: Treat both ASCII () and full-width （） as valid parentheses. Inside them, alternates may be separated by / or ／.\n\n5) Handling multiple segments and delimiters\n   - Common delimiters: semicolons (;), pipes (|), slashes (/), line breaks, commas.\n   - Split cautiously; slashes can be part of legitimate names (e.g., “A/S”, “S/O”). Do not split on slashes that are clearly part of a name token unless they occur inside parentheses as alternate separators.\n   - Parenthetical descriptors may include phrases like “(FORMERLY …)” or other metadata; extract names into the appropriate category and exclude descriptor text.\n   - If the input contains multiple names separated by delimiters with no explicit labels, treat each as a separate full_name.\n\n6) Remove non-name content (cleaning)\n   - Discard address/contact/metadata and similar noise. Common noise cues (case-insensitive): “address”, “listed”, “at”, “tel”, “telephone”, “phone”, “fax”, “email”, “website”, “http”, “https”, “www”, “contact”, “reg”, “registration”, “CIN”, “GST”, “VAT”, “PAN”, “PO Box”, “P.O.”, “No.”, “Suite”, “Floor”, “Road”, “Street”, “Bldg”, “Building”, “Room”, “Zip”, “City”, “Country”.\n   - When such noise appears after a plausible name, stop the name at the last valid character before the noise and ignore the rest of that noise segment.\n   - Keep corporate/legal designators as part of the name (e.g., “Ltd”, “Ltd.”, “Limited”, “Inc”, “Inc.”, “LLC”, “LLP”, “PLC”, “AG”, “GmbH”, “BV”, “NV”, “S.A.”, “SAS”, “SARL”, “Oy”, “AB”, “AS”, “A/S”, “Sp. z o.o.”).\n   - Do not treat industry words like “Bank”, “Financials”, “Industries” as noise.\n\n7) Special handling for colon-led descriptive constructions (important domain nuance)\n   - Some sources (e.g., sanctions or sectoral lists) use a pattern like:\n     “Group/Department/Entity: <generic category> (<parenthetical qualifiers>) <qualifying clause> …”\n   - In such cases, interpret it as a single named group with appended qualifiers. Build one full_name by:\n     a) Taking the segment before the colon as the base.\n     b) Appending the qualifying clause(s) that follow (e.g., “not under …”, “subject to …”, “excluding …”, etc.).\n     c) If the segment immediately after the colon is a generic category noun phrase (e.g., “Nuclear reactors”) preceding the true qualifying clause, omit that generic category phrase but keep any parenthetical qualifiers directly attached to it and move those parentheses right after the base segment.\n   - Preserve the exact text of all retained parts; only the colon and the omitted generic category noun phrase are removed.\n   - Example:\n     Input: “Department of Atomic Energy facilities: Nuclear reactors (including power plants) not under International Atomic Energy Agency (IAEA) safeguards (excluding Kundankulam 1 and 2)”\n     Output:\n       full_name: [\"Department of Atomic Energy facilities (including power plants) not under International Atomic Energy Agency (IAEA) safeguards (excluding Kundankulam 1 and 2)\"]\n       alias: []\n       weak_alias: []\n       previous_name: []\n   - Do not apply this transformation if the post-colon segment clearly presents a distinct name rather than a generic category.\n\n8) De-duplication and category precedence\n   - Remove exact duplicates within and across categories.\n   - If the same name is eligible for multiple categories, prefer the most specific:\n     previous_name > alias > weak_alias > full_name.\n\nOutput format:\n- Return a single JSON object with exactly these keys: full_name, alias, weak_alias, previous_name.\n- Each value is an array of strings (use [] if none).\n- Preserve within-category order as they appear/are derived from the input (alias expansions follow the ordering rule in Section 4).\n- Do not include any other keys or commentary.\n\nValidation checklist before returning:\n- Names are exact substrings from the input after HTML-entity decoding and allowed outer trimming; internal spacing/casing preserved.\n- No invented spacing/casing/expansions.\n- Non-name noise removed; legal designators kept.\n- Parenthetical alternates expanded per cross-product rule; no standalone partial tokens output unless present in input.\n- Correct categories assigned per explicit cues and parenthetical alternate rules.\n- Special colon-led construction handled when applicable.\n- A single JSON object with arrays for full_name, alias, weak_alias, previous_name.\n\nAdditional examples:\n- “O&#39;KANE”\n  ⇒ full_name: [\"O'KANE\"]; alias: []; weak_alias: []; previous_name: [].\n- “Aleksei(Oleksiy) MOZGOVOY(MOZGOVOI/MOZGOVY/MOZHOVY/MOZHOVYY)”\n  ⇒ full_name: [\"Aleksei MOZGOVOY\"]\n     alias: [\"Aleksei MOZGOVOI\", \"Aleksei MOZGOVY\", \"Aleksei MOZHOVY\", \"Aleksei MOZHOVYY\",\n             \"Oleksiy MOZGOVOY\", \"Oleksiy MOZGOVOI\", \"Oleksiy MOZGOVY\", \"Oleksiy MOZHOVY\", \"Oleksiy MOZHOVYY\"]\n     weak_alias: []\n     previous_name: []\n- “Elmira Khaimourzina（Khaimurzina/Haimurzyna）”\n  ⇒ full_name: [\"Elmira Khaimourzina\"]\n     alias: [\"Elmira Khaimurzina\", \"Elmira Haimurzyna\"]\n     weak_alias: []\n     previous_name: []",
    "fields": [
      {
        "prefix": "String:",
        "description": "${string}"
      },
      {
        "prefix": "Full Name:",
        "description": "A list of the names of this entity, potentially in various languages and transliterations."
      },
      {
        "prefix": "Alias:",
        "description": "A list of alternative names or nicknames for this entity."
      },
      {
        "prefix": "Weak Alias:",
        "description": "A list of names with low confidence or a very low degree of uniqueness in the context of legal entity names."
      },
      {
        "prefix": "Previous Name:",
        "description": "A list of names this entity was known by in the past."
      }
    ]
  },
  "lm": null,
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.3",
      "cloudpickle": "3.1"
    }
  }
}
