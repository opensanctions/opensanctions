{
  "traces": [],
  "train": [],
  "demos": [],
  "signature": {
    "instructions": "You are given a single input string and must extract names and categorize them into full_name, alias, weak_alias, and previous_name. Return a JSON object with exactly those four keys, each mapped to an array of strings. Always preserve the original casing and character content as it appears in the input for any extracted name. Do not include commentary or extra fields.\n\nWhat to output\n- A JSON object with keys exactly:\n  - full_name: []\n  - alias: []\n  - weak_alias: []\n  - previous_name: []\n- Each value is an array of cleaned strings (can be empty). Maintain the order of appearance from the input within each category after cleaning and deduplication.\n- Do not place the same cleaned string into more than one category; prefer the most specific category (e.g., previous_name over alias).\n\nPreprocessing and cleaning\n1) Decode HTML entities before any processing:\n   - &#39; → '\n   - &amp; → &\n   - &quot; → \"\n   - Apply decoding to the whole input.\n2) Trim leading/trailing whitespace.\n3) Remove leading/trailing quotes, brackets, and parentheses around extracted names (but keep parentheses content used to form names as described below).\n4) Remove trailing punctuation such as semicolons, commas, and periods, unless clearly part of the name.\n5) Collapse multiple spaces to a single space.\n6) Keep valid in-name characters:\n   - Letters (all Unicode), digits when part of the name, spaces\n   - Hyphens, apostrophes, periods, ampersands, slashes\n   - Corporate/legal suffixes (e.g., LLC, Ltd, Inc., Co, JSC, PLC, Bank)\n   - Relationship tokens like “S/O”, “D/O”, “W/O”, “s/o”, “d/o”, “w/o” (preserve casing exactly as in input)\n\nHow to find and categorize content\nA) Determine main name(s)\n- After all qualifier handling (see below), any remaining primary name text is the full_name.\n- If multiple standalone names are present in the input without qualifiers (often separated by semicolons or clear list punctuation at top level), treat each as its own full_name entry in left-to-right order.\n  • Example: \"TBL Trade Block London; Dalipi Holding Co\" → full_name: [\"TBL Trade Block London\", \"Dalipi Holding Co\"]\n\nB) Qualifier keywords and mapping\n- Recognize the following explicit indicators (case-insensitive, punctuation-insensitive) and map the captured names that follow them:\n  • previous_name: \"formerly\", \"formerly known as\", \"f/k/a\", \"fka\", \"ex-\", \"previously\", \"previous name\"\n  • alias (strong alias): \"aka\", \"a.k.a.\", \"also known as\", \"alias\"\n  • weak_alias (trade/operational): \"d/b/a\", \"DBA\", \"t/a\", \"trading as\", \"doing business as\", \"operating as\"\n  • \"now known as\", \"n/k/a\", \"nk/a\": the target of this phrase is the current full_name; the original/main becomes previous_name.\n- For each qualifier segment, capture the subsequent name text up to the next delimiter (comma, semicolon, end of parenthesis, or end of string). Clean it (including removing surrounding quotes).\n- Do not include the qualifier words in the extracted name.\n\nC) Parenthetical and descriptor handling\n- Strip and ignore non-name descriptors from parentheses (e.g., \"(entity)\", \"(Russian entity)\", nationalities, generic descriptors) when they are not names and have no qualifier terms.\n- Extract names from explicit qualifiers even if they occur inside parentheses.\n\nD) Parenthetical name alternatives attached to tokens (critical nuance)\n- When parentheses immediately follow a name token with name-like content (letters/digits/valid name chars, optionally with slashes or commas), treat the content as alternative tokens for that exact position.\n  • Example patterns: \"Igor(Ihor)\", \"KAKIDZYANOV(KAKIZYANOV/KAKIDZHANOV)\"\n- Build the full_name from the base tokens (the tokens outside parentheses).\n- Create aliases by substituting the base token with each alternative while keeping the rest of the name intact.\n- If multiple tokens (e.g., given name and surname) each have alternatives, generate the cross-product of alternatives across those positions, preserving order and spacing.\n- Do not output standalone partial tokens as names when the context shows a full personal or organizational name; combine them with the other tokens that form the full name in the string.\n- Consider these aliases “strong” aliases (place in alias), even if no \"aka\" keyword is present, provided the parentheses clearly indicate name alternatives rather than descriptors.\n  • Example: \"Igor(Ihor) KAKIDZYANOV(KAKIZYANOV/KAKIDZHANOV)\"\n    - full_name: [\"Igor KAKIDZYANOV\"]\n    - alias: [\"Ihor KAKIDZYANOV\", \"Igor KAKIZYANOV\", \"Ihor KAKIZYANOV\", \"Igor KAKIDZHANOV\", \"Ihor KAKIDZHANOV\"]\n    - Do not output \"KAKIZYANOV\" or \"KAKIDZHANOV\" alone.\n\nE) Mid-name qualifier reconstruction\n- When a qualifier with a name appears in parentheses embedded within the main name between two segments of the main name (e.g., A (A.K.A. X) B):\n  • full_name = cleaned concatenation of the main name segments surrounding the parentheses (\"A B\")\n  • Place the captured name from the qualifier into the correct category (alias/previous_name/weak_alias) and append the trailing right-side segment(s) that are part of the main name to the captured name.\n  • Do not prepend the left-side segment unless the qualifier implies it replaces the right side.\n  • Example: \"PEARL (A.K.A. NEI-CHIEN CHU) LI\"\n    - full_name: [\"PEARL LI\"]\n    - alias: [\"NEI-CHIEN CHU LI\"]\n\nF) Relationship tokens\n- Treat tokens like \"S/O\", \"D/O\", \"W/O\" (and their case variants) as part of the person’s name when they appear in-line. Preserve exact casing.\n  • Example: \"Sree Gaithiri d/o KUNNASEGARAN\" → full_name: [\"Sree Gaithiri d/o KUNNASEGARAN\"]\n\nG) Multiple qualifiers and delimiters\n- Support multiple qualifier segments; handle each independently.\n- If multiple names are listed after a qualifier, separated by commas/semicolons/slashes, capture each as a separate entry in the mapped category.\n- For qualifier segments, stop capturing at the next delimiter (comma, semicolon, closing parenthesis) or end of string.\n\nH) Corporate/legal suffixes\n- Keep corporate/legal suffixes exactly as they appear (e.g., \"Co\", \"LLC\", \"Ltd\", \"Inc.\", \"Bank\") within the name. Do not remove or expand them.\n\nI) Do not invent or normalize\n- Extract only what is explicitly present in the input.\n- Do not change capitalization, expand abbreviations, or title-case names.\n- Do not infer aliases or previous names without explicit indicators or clear parenthetical alternatives adjacent to tokens as described above.\n\nJ) Deduplication and order\n- Deduplicate within each category by exact string match after cleaning. Keep the first occurrence.\n- Preserve order of appearance from the input within each category.\n\nFinal determination of full_name\n- After processing and removing qualifier segments and descriptors, the remaining primary string(s) is/are the full_name entry/entries.\n- If \"now known as\"/\"n/k/a\"/\"nk/a\" indicates a new current name, use that captured name as full_name and place the earlier name into previous_name.\n\nOutput format\n- Return only a JSON object with keys: full_name, alias, weak_alias, previous_name.\n- Each value is an array of strings (possibly empty).",
    "fields": [
      {
        "prefix": "String:",
        "description": "${string}"
      },
      {
        "prefix": "Full Name:",
        "description": "A list of the names of this entity, potentially in various languages and transliterations."
      },
      {
        "prefix": "Alias:",
        "description": "A list of alternative but still fully descriptive names for this entity."
      },
      {
        "prefix": "Weak Alias:",
        "description": "A list of names with low confidence or a very low degree of uniqueness in the context of legal entity names. Includes clear nicknames with no similarity to the full name."
      },
      {
        "prefix": "Previous Name:",
        "description": "A list of names this entity was known by in the past."
      }
    ]
  },
  "lm": null,
  "metadata": {
    "dependency_versions": {
      "python": "3.13",
      "dspy": "3.0.3",
      "cloudpickle": "3.1"
    }
  }
}
